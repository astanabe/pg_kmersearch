-- Test partitioning support functions
SET client_min_messages = WARNING;
-- Limit parallel workers to 2 for consistent test results
SET max_parallel_maintenance_workers = 2;
CREATE EXTENSION IF NOT EXISTS pg_kmersearch;
-- Set maintenance_work_mem for batch processing
SET maintenance_work_mem = '64MB';
-- Test 1: Create test table with DNA2 column
CREATE TABLE test_sequences (
    id serial PRIMARY KEY,
    sequence dna2 NOT NULL,
    description text
);
-- Insert test data
INSERT INTO test_sequences (sequence, description) VALUES
    ('ATCGATCGATCGATCG', 'Test sequence 1'),
    ('GCTAGCTAGCTAGCTA', 'Test sequence 2'),
    ('TTTTTTTTTTTTTTTT', 'Test sequence 3'),
    ('AAAAAAAAAAAAAAAA', 'Test sequence 4'),
    ('ATCGATCGATCGATCG', 'Test sequence 5'),
    ('GCTAGCTAGCTAGCTA', 'Test sequence 6'),
    ('CCCCCCCCCCCCCCCC', 'Test sequence 7'),
    ('GGGGGGGGGGGGGGGG', 'Test sequence 8');
-- Test 2: Verify table is not partitioned
SELECT c.relname, c.relkind 
FROM pg_class c 
WHERE c.oid = 'test_sequences'::regclass;
    relname     | relkind 
----------------+---------
 test_sequences | r
(1 row)

-- Test 3: Convert table to partitioned table with 4 partitions
SET client_min_messages = NOTICE;
\set VERBOSITY terse
SELECT kmersearch_partition_table('test_sequences', 4);
INFO:  Starting partition table data migration: 8 rows to migrate in batches of 16384
INFO:  Migration completed: 100% (8 / 8 rows migrated)
NOTICE:  drop cascades to 5 other objects
INFO:  Partition table creation completed successfully for table 'test_sequences' with 4 partitions
 kmersearch_partition_table 
----------------------------
 
(1 row)

\set VERBOSITY default
SET client_min_messages = WARNING;
-- Test 4: Verify table is now partitioned
SELECT c.relname, c.relkind 
FROM pg_class c 
WHERE c.oid = 'test_sequences'::regclass;
    relname     | relkind 
----------------+---------
 test_sequences | p
(1 row)

-- Test 5: List partitions
SELECT c.relname as partition_name
FROM pg_inherits i
JOIN pg_class c ON i.inhrelid = c.oid
WHERE i.inhparent = 'test_sequences'::regclass
ORDER BY c.relname;
  partition_name  
------------------
 test_sequences_0
 test_sequences_1
 test_sequences_2
 test_sequences_3
(4 rows)

-- Test 6: Verify data was migrated correctly
SELECT COUNT(*) as total_rows FROM test_sequences;
 total_rows 
------------
          8
(1 row)

SELECT sequence, description FROM test_sequences ORDER BY id;
     sequence     |   description   
------------------+-----------------
 ATCGATCGATCGATCG | Test sequence 1
 GCTAGCTAGCTAGCTA | Test sequence 2
 TTTTTTTTTTTTTTTT | Test sequence 3
 AAAAAAAAAAAAAAAA | Test sequence 4
 ATCGATCGATCGATCG | Test sequence 5
 GCTAGCTAGCTAGCTA | Test sequence 6
 CCCCCCCCCCCCCCCC | Test sequence 7
 GGGGGGGGGGGGGGGG | Test sequence 8
(8 rows)

-- Test 7: Error case - try to partition already partitioned table
SELECT kmersearch_partition_table('test_sequences', 4);
ERROR:  table "test_sequences" is already a partitioned table
-- Test 8: Test search functionality on partitioned table
SET kmersearch.kmer_size = 4;
SET kmersearch.preclude_highfreq_kmer = false;
SELECT COUNT(*) FROM test_sequences WHERE sequence =% 'ATCGATCG';
 count 
-------
     2
(1 row)

-- Test 9: Create test table with DNA4 column
CREATE TABLE test_sequences_dna4 (
    id serial PRIMARY KEY,
    sequence dna4 NOT NULL
);
INSERT INTO test_sequences_dna4 (sequence) VALUES
    ('ATCGATCGATCGATCG'),
    ('GCTAGCTAGCTAGCTA'),
    ('MMMMMMMMMMMMMMMM'),
    ('NNNNNNNNNNNNNNNN');
-- Test 10: Convert DNA4 table to partitioned
SET client_min_messages = NOTICE;
\set VERBOSITY terse
SELECT kmersearch_partition_table('test_sequences_dna4', 2);
INFO:  Starting partition table data migration: 4 rows to migrate in batches of 16384
INFO:  Migration completed: 100% (4 / 4 rows migrated)
NOTICE:  drop cascades to 3 other objects
INFO:  Partition table creation completed successfully for table 'test_sequences_dna4' with 2 partitions
 kmersearch_partition_table 
----------------------------
 
(1 row)

\set VERBOSITY default
SET client_min_messages = WARNING;
-- Test 11: Error case - table without DNA column
CREATE TABLE test_no_dna_table (
    id serial PRIMARY KEY,
    name text
);
SELECT kmersearch_partition_table('test_no_dna_table', 2);
ERROR:  table must have at least one DNA2 or DNA4 column
-- Test 12: Error case - table with multiple DNA columns
CREATE TABLE test_multi_dna_table (
    id serial PRIMARY KEY,
    seq1 dna2,
    seq2 dna4
);
SELECT kmersearch_partition_table('test_multi_dna_table', 2);
ERROR:  table has 2 DNA2/DNA4 columns, but exactly one is required
-- Test 13: Test partition_count validation
CREATE TABLE test_regular_table (
    id serial PRIMARY KEY,
    sequence dna2
);
SELECT kmersearch_partition_table('test_regular_table', 0);
ERROR:  partition_count must be at least 1
SELECT kmersearch_partition_table('test_regular_table', -1);
ERROR:  partition_count must be at least 1
-- Test 14: Test tablespace parameter (test with default behavior)
CREATE TABLE test_tablespace_table (
    id serial PRIMARY KEY,
    sequence dna2 NOT NULL
);
INSERT INTO test_tablespace_table (sequence) VALUES
    ('ATCGATCGATCGATCG'),
    ('GCTAGCTAGCTAGCTA');
-- Convert to partitioned table without specifying tablespace (uses default)
SET client_min_messages = NOTICE;
\set VERBOSITY terse
SELECT kmersearch_partition_table('test_tablespace_table', 2);
INFO:  Starting partition table data migration: 2 rows to migrate in batches of 16384
INFO:  Migration completed: 100% (2 / 2 rows migrated)
NOTICE:  drop cascades to 3 other objects
INFO:  Partition table creation completed successfully for table 'test_tablespace_table' with 2 partitions
 kmersearch_partition_table 
----------------------------
 
(1 row)

\set VERBOSITY default
SET client_min_messages = WARNING;
-- Verify partitions were created
SELECT c.relname as partition_name
FROM pg_inherits i
JOIN pg_class c ON i.inhrelid = c.oid
WHERE i.inhparent = 'test_tablespace_table'::regclass
ORDER BY c.relname;
     partition_name      
-------------------------
 test_tablespace_table_0
 test_tablespace_table_1
(2 rows)

-- Test 15: Test with NULL tablespace parameter (should work same as default)
CREATE TABLE test_null_tablespace (
    id serial PRIMARY KEY,
    sequence dna2 NOT NULL
);
INSERT INTO test_null_tablespace (sequence) VALUES
    ('ATCGATCGATCGATCG'),
    ('GCTAGCTAGCTAGCTA');
-- Convert to partitioned table with NULL tablespace
SELECT kmersearch_partition_table('test_null_tablespace', 2, NULL);
INFO:  Starting partition table data migration: 2 rows to migrate in batches of 16384
INFO:  Migration completed: 100% (2 / 2 rows migrated)
INFO:  Partition table creation completed successfully for table 'test_null_tablespace' with 2 partitions
 kmersearch_partition_table 
----------------------------
 
(1 row)

-- Verify it worked
SELECT c.relname as partition_name
FROM pg_inherits i
JOIN pg_class c ON i.inhrelid = c.oid
WHERE i.inhparent = 'test_null_tablespace'::regclass
ORDER BY c.relname;
     partition_name     
------------------------
 test_null_tablespace_0
 test_null_tablespace_1
(2 rows)

-- Test 16: Test high-frequency k-mer analysis on partitioned table
-- Create a larger test table
CREATE TABLE test_highfreq_regular (
    id serial PRIMARY KEY,
    sequence dna2 NOT NULL
);
CREATE TABLE test_highfreq_partitioned (
    id serial PRIMARY KEY,
    sequence dna2 NOT NULL
);
-- Insert identical data into both tables
INSERT INTO test_highfreq_regular (sequence)
SELECT 
    CASE (i % 10)
        WHEN 0 THEN 'ATCGATCGATCGATCGATCGATCGATCGATCG'::dna2  -- High frequency pattern
        WHEN 1 THEN 'ATCGATCGATCGATCGATCGATCGATCGATCG'::dna2  -- Same high frequency
        WHEN 2 THEN 'GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA'::dna2
        WHEN 3 THEN 'TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT'::dna2
        WHEN 4 THEN 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'::dna2
        WHEN 5 THEN 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'::dna2
        WHEN 6 THEN 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'::dna2
        WHEN 7 THEN 'ATGCATGCATGCATGCATGCATGCATGCATGC'::dna2
        WHEN 8 THEN 'CGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCG'::dna2
        ELSE 'TATATATATATATATATATATATATATATATA'::dna2
    END
FROM generate_series(1, 100) i;
-- Copy same data to partitioned table
INSERT INTO test_highfreq_partitioned (sequence)
SELECT sequence FROM test_highfreq_regular ORDER BY id;
-- Convert the second table to partitioned with 4 partitions
SELECT kmersearch_partition_table('test_highfreq_partitioned', 4);
INFO:  Starting partition table data migration: 100 rows to migrate in batches of 16384
INFO:  Migration completed: 100% (100 / 100 rows migrated)
INFO:  Partition table creation completed successfully for table 'test_highfreq_partitioned' with 4 partitions
 kmersearch_partition_table 
----------------------------
 
(1 row)

-- Configure analysis parameters
SET kmersearch.kmer_size = 8;
SET kmersearch.max_appearance_rate = 0.15;  -- 15% threshold
SET kmersearch.max_appearance_nrow = 0;     -- Use only rate-based threshold
-- Test 17: Perform high-frequency analysis on regular table
SELECT 
    total_rows,
    highfreq_kmers_count,
    max_appearance_rate_used,
    max_appearance_nrow_used,
    parallel_workers_used
FROM kmersearch_perform_highfreq_analysis('test_highfreq_regular', 'sequence');
INFO:  Starting high-frequency k-mer analysis: 100 rows in 1 blocks with 2 parallel workers
INFO:  Batch 1 completed: 100 / 100 rows processed of column sequence in table test_highfreq_regular (final)
INFO:  Parallel scan completed. Starting aggregation of results.
INFO:  Starting parallel aggregation of 2 temporary files
INFO:  Merge stage 1: 2 files, 1 parallel workers
INFO:  Merge completed after 1 stages
INFO:  Writing 25 high-frequency k-mers to kmersearch_highfreq_kmer table...
INFO:  Successfully wrote 25 high-frequency k-mers to database.
 total_rows | highfreq_kmers_count | max_appearance_rate_used | max_appearance_nrow_used | parallel_workers_used 
------------+----------------------+--------------------------+--------------------------+-----------------------
        100 |                   25 |                     0.15 |                       15 |                     2
(1 row)

-- Test 18: Perform high-frequency analysis on partitioned table
-- Limit to 1 parallel worker for consistent test results on partitioned tables
SET max_parallel_maintenance_workers = 1;
SELECT 
    total_rows,
    highfreq_kmers_count,
    max_appearance_rate_used,
    max_appearance_nrow_used,
    parallel_workers_used
FROM kmersearch_perform_highfreq_analysis('test_highfreq_partitioned', 'sequence');
INFO:  Starting high-frequency k-mer analysis: 100 rows in 3 blocks with 1 parallel workers
INFO:  Batch 1 completed: 100 / 100 rows processed of column sequence in table test_highfreq_partitioned (final)
INFO:  Parallel scan completed. Starting aggregation of results.
INFO:  Writing 25 high-frequency k-mers to kmersearch_highfreq_kmer table...
INFO:  Successfully wrote 25 high-frequency k-mers to database.
 total_rows | highfreq_kmers_count | max_appearance_rate_used | max_appearance_nrow_used | parallel_workers_used 
------------+----------------------+--------------------------+--------------------------+-----------------------
        100 |                   25 |                     0.15 |                       15 |                     1
(1 row)

-- Restore parallel workers setting
SET max_parallel_maintenance_workers = 2;
-- Test 19: Verify that both analyses produced identical results
-- Compare high-frequency k-mers from both tables
SELECT 
    CASE 
        WHEN (
            SELECT COUNT(*) FROM kmersearch_highfreq_kmer 
            WHERE table_oid = 'test_highfreq_regular'::regclass
        ) = (
            SELECT COUNT(*) FROM kmersearch_highfreq_kmer 
            WHERE table_oid = 'test_highfreq_partitioned'::regclass
        )
        THEN 'Same count of high-frequency k-mers'
        ELSE 'Different count of high-frequency k-mers'
    END as comparison_result;
          comparison_result          
-------------------------------------
 Same count of high-frequency k-mers
(1 row)

-- Test 20: Clean up analysis results
SELECT * FROM kmersearch_undo_highfreq_analysis('test_highfreq_regular', 'sequence');
 dropped_analyses | dropped_highfreq_kmers | freed_storage_bytes 
------------------+------------------------+---------------------
                1 |                     25 |                1600
(1 row)

SELECT * FROM kmersearch_undo_highfreq_analysis('test_highfreq_partitioned', 'sequence');
 dropped_analyses | dropped_highfreq_kmers | freed_storage_bytes 
------------------+------------------------+---------------------
                1 |                     25 |                1600
(1 row)

-- Test 21: Test with different k-mer size and parallel workers
SET kmersearch.kmer_size = 4;
-- Analyze regular table with 2 parallel workers
SELECT 
    total_rows,
    highfreq_kmers_count,
    parallel_workers_used
FROM kmersearch_perform_highfreq_analysis('test_highfreq_regular', 'sequence');
INFO:  Starting high-frequency k-mer analysis: 100 rows in 1 blocks with 2 parallel workers
INFO:  Batch 1 completed: 100 / 100 rows processed of column sequence in table test_highfreq_regular (final)
INFO:  Parallel scan completed. Starting aggregation of results.
INFO:  Starting parallel aggregation of 2 temporary files
INFO:  Merge stage 1: 2 files, 1 parallel workers
INFO:  Merge completed after 1 stages
INFO:  Writing 29 high-frequency k-mers to kmersearch_highfreq_kmer table...
INFO:  Successfully wrote 29 high-frequency k-mers to database.
 total_rows | highfreq_kmers_count | parallel_workers_used 
------------+----------------------+-----------------------
        100 |                   29 |                     2
(1 row)

-- Analyze partitioned table with 1 parallel worker for consistent results
SET max_parallel_maintenance_workers = 1;
SELECT 
    total_rows,
    highfreq_kmers_count,
    parallel_workers_used
FROM kmersearch_perform_highfreq_analysis('test_highfreq_partitioned', 'sequence');
INFO:  Starting high-frequency k-mer analysis: 100 rows in 3 blocks with 1 parallel workers
INFO:  Batch 1 completed: 100 / 100 rows processed of column sequence in table test_highfreq_partitioned (final)
INFO:  Parallel scan completed. Starting aggregation of results.
INFO:  Writing 29 high-frequency k-mers to kmersearch_highfreq_kmer table...
INFO:  Successfully wrote 29 high-frequency k-mers to database.
 total_rows | highfreq_kmers_count | parallel_workers_used 
------------+----------------------+-----------------------
        100 |                   29 |                     1
(1 row)

-- Restore parallel workers setting
SET max_parallel_maintenance_workers = 2;
-- Clean up analysis results
SELECT * FROM kmersearch_undo_highfreq_analysis('test_highfreq_regular', 'sequence');
 dropped_analyses | dropped_highfreq_kmers | freed_storage_bytes 
------------------+------------------------+---------------------
                1 |                     29 |                1856
(1 row)

SELECT * FROM kmersearch_undo_highfreq_analysis('test_highfreq_partitioned', 'sequence');
 dropped_analyses | dropped_highfreq_kmers | freed_storage_bytes 
------------------+------------------------+---------------------
                1 |                     29 |                1856
(1 row)

-- Reset parameters
RESET kmersearch.kmer_size;
RESET kmersearch.max_appearance_rate;
RESET kmersearch.max_appearance_nrow;
-- Cleanup
DROP TABLE IF EXISTS test_sequences CASCADE;
DROP TABLE IF EXISTS test_sequences_dna4 CASCADE;
DROP TABLE IF EXISTS test_regular_table CASCADE;
DROP TABLE IF EXISTS test_no_dna_table CASCADE;
DROP TABLE IF EXISTS test_multi_dna_table CASCADE;
DROP TABLE IF EXISTS test_tablespace_table CASCADE;
DROP TABLE IF EXISTS test_null_tablespace CASCADE;
DROP TABLE IF EXISTS test_highfreq_regular CASCADE;
DROP TABLE IF EXISTS test_highfreq_partitioned CASCADE;
DROP EXTENSION pg_kmersearch CASCADE;
SET client_min_messages = NOTICE;
